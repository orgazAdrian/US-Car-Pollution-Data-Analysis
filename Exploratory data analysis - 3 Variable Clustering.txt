%load_ext watermark
%watermark

import pandas as pd

%matplotlib.inline
import matplotlib.pyplot as plt

plt.rcParams['figure.figsize'] = (12,12) #10 inch for both wide and height for all plots

### Data Reading

vehicles = pd.read_csv("../data/vechiles.2.clean_analysis.csv")

vehicles.head()

##### ON this step we are adding those variables which can be grouped by a more generical type. This, will help us to analyze by groups insted of by individual elements.
##### To do so, we are going to see how many unique values each category may have

def unique_col_values(df):
    for column in df:
        print("{} | {} | {} ".format(
            df[column].name, len(df[column].unique()), df[column].dtype
        ))

### Categorical variable Clustering

### Vehicle Type

vehicles.VClass.unique()

small = ['Compact Cars', 'Subcompact Cars', 'Two Setters', 'Minicompact Cars']
medium = ['Midsize Cars']
large = ['Large Cars']

vehicles.loc[vehicles['VClass'].isin(small),
            'VClass'] = 'Small Cars'

vehicles.loc[vehicles['VClass'].isin(medium),
            'VClass'] = 'Medium Cars'

vehicles.loc[vehicles['VClass'].isin(large),
            'VClass'] = 'Large Cars'

vehicles.loc[vehicles['VClass'].str.contanis('Truck'),
            'VClass'] = 'Trucks'

vehicles.loc[vehicles['VClass'].str.contanis('Special Purpose'),
            'VClass'] = 'Special Cars'

vehicles.loc[vehicles['VClass'].str.contanis('Sport'),
            'VClass'] = 'Sports Cars'

vehicles.loc[vehicles['VClass'].str.contanis('Station'),
            'VClass'] = 'Family Cars'

vehicles.loc[vehicles['VClass'].str.lower().str.contanis('van'),
            'VClass'] = 'Van Cars'



vehicles.VClass = vehicles.VClass.astype("category")

vehicles.VClass.value_counts()

### Traction Type

vehicles.drive.unique()

vehicles["drive"] = "two"
vehicles["drive"].vehicles.drive.isin([
    "4-Wheel or All-Wheel Drive", "All-Wheel Drive",
    "4-Wheel Drive", "Part-time 4-Wheel Drive"
])] = "four"


##### This warning inform us that we are alterating a copy of vehicles(vehicles_year), not vehicles.
##### In order to undo this:

pd.set_option('chained_assignment', None)

##### Or symply by using loc to asing values on pandas

vechiles["drive"] = "two"
vehicles.lov[vechiles.drive].isin([
    "4-Wheel or All-Wheel Drive", "All-Wheel Drive",
    "4-Wheel Drive", "Part-time 4-Wheel Drive"
]), "drive"] = "four"


##### Pandas has a special dtype for categorical variables called category. If we specify to pandas that is a field is a category instead of an object, it will raise the functionalities we can use.
#### Besides, categories require less space in memory


vehicles.drive = vehicles.drive.astype("category")

### Transmission Type

vehicles.trany.unique()

vehicles['trany'] = "Automatic"
vehicles.loc[vehicles['trany'].str.startswith('M'),
            'trany'] = 'Manual'

##### In case of an error, we found a mistake on step 2(QA), since there exist vehicles with not data transmission
vehicles[vehicles['trany'].isnull()]


vehicles['trany'] = "Automatic"
vehicles['trany'][
    (vehicles['trany'].notnull() & (vehicles['trany'].str.startswith('M'))
    ] = "Manual"
     




vehicles.trany = vehicles.trany.astype("category")
    
vehicles.trany.value_counts()
    
### Fuel Type
    
vehicles.fuelType.value.counts()

vehicles['fuelType'] = "Other type of fuel"

vehicles.loc[vehicles['fuelType'] == 'Regular',
            'fuelType'] = 'Normal'

vehicles.loc[vehicles['fuelType'] == 'Premium',
            'fuelType'] = 'Premium'

vehicles.loc[vehicles['fuelType'].str.contains('Electricity'),
            'fuelType'] = 'Hybrid'

vehicles.fuelType = vehicles.fuelType.astype("category")

vehicles.fuelType.value_counts()

vehicles.head()

### Continuous variables Clustering 

##### We are implementing continuous variables into categorical through quintiles

types_motor_size = ['very small', 'small', 'medium', 'large', 'very large']
vehicles[types_motor_size] = pd.qcut(vehicles['displ'],
                                     5, types_motor_size)

types_consumption = ['very small', 'small', 'medium', 'large', 'very large']
vehicles['co2TailpipeGpm'] = pd.qcut(vehicles['co2TailpipeGpm'],
                                    5, types_consumption)

vehicles.head()


#### When checking the dataset, we noticed there is an error between the types_consumption and co2. Those cars which consume more fuel are, indeed, those that are going to emit more polution.
#### So, we see how the variables relates with each other

vehicles.plot.scatter(x= "consumption", y="co2")

#### This inverse relation are explained on the documentation of the dataset. CO2 consumption is measured by grams per mile, while the consumption is measured by miles per galon.
### We need to invert the consumption to galons per mile. 
##### Besides, we are going to measure litres per galon.

litres_per_galon = 3.78541
vehicles['consumption_litres_per_mile'] = lites_per_galon / vehicles.consumption

vehicles.plot.scatter(x="consumption_litres_mile", y="co2");

##### We are going to calculate the consumption levels related to the new variable

consumption_types = ['very small','small','medium','large','very large']
vehicles['consumption_type'] = pd.qcut(vehicles['consumption_litres_mile'],
                                      5, labels = consumption_types)















    

    
  
 



